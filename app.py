"""
TechLance Solutions — Phase 4: Analytics Dashboard & Recommendations
Single-file Streamlit app (runs with `streamlit run app.py`).
If you *must* run with `python app.py`, see the __main__ block at the bottom
which attempts to invoke Streamlit as a subprocess for a single-command UX.

Place CSVs in ./data directory with the following schema:
- usage_data.csv: EmployeeID, BenefitID, UsageFrequency, LastUsedDate
- employee_data.csv: EmployeeID, Age, Gender, Department, Tenure
- benefits_data.csv: BenefitID, BenefitType, BenefitSubType, BenefitCost
- feedback_data.csv: EmployeeID, BenefitID, SatisfactionScore, Comments

App features
- Caching (st.cache_data) for faster reloads
- Filters: Department, Age range, BenefitSubType
- Metrics: Utilization, Avg Satisfaction, Segments, Cost & ROI proxies
- Visualizations: usage trends, satisfaction by benefit, department heatmap, segments
- “Generative AI insights” (rule-based text summarizer over comments)
- Export: KPI snapshot + recommendations to HTML (download button)

Dependencies (common in Streamlit Cloud / local env):
- streamlit, pandas, numpy, altair, plotly.express

Author: Generated by ChatGPT
"""

from __future__ import annotations
import os
import sys
import io
import base64
import textwrap
from datetime import datetime
import subprocess

import pandas as pd
import numpy as np
import streamlit as st
import altair as alt
import plotly.express as px

# -----------------------------
# Constants & Utilities
# -----------------------------
DATA_DIR = os.path.join(os.path.dirname(__file__), "data")
COMPANY = "TechLance Solutions"
EMPLOYEES = 5000
ANNUAL_BENEFITS_COST = 12_000_000
YOY_COST_INCREASE = 0.15

st.set_page_config(page_title=f"{COMPANY} Benefits Analytics", layout="wide")

# -----------------------------
# Cached Data Loaders
# -----------------------------
@st.cache_data(show_spinner=True)
def load_csv(path: str) -> pd.DataFrame:
    df = pd.read_csv(path)
    return df

@st.cache_data(show_spinner=True)
def load_all_data(data_dir: str) -> dict[str, pd.DataFrame]:
    paths = {
        "usage": os.path.join(data_dir, "usage_data.csv"),
        "employees": os.path.join(data_dir, "employee_data.csv"),
        "benefits": os.path.join(data_dir, "benefits_data.csv"),
        "feedback": os.path.join(data_dir, "feedback_data.csv"),
    }
    data = {}
    missing = []
    for k, p in paths.items():
        if os.path.exists(p):
            data[k] = load_csv(p)
        else:
            missing.append(p)
    if missing:
        st.warning("Missing files: " + ", ".join(missing))
    return data

# -----------------------------
# Feature Engineering / Integration
# -----------------------------
@st.cache_data(show_spinner=True)
def integrate(data: dict[str, pd.DataFrame]) -> pd.DataFrame:
    usage = data.get("usage", pd.DataFrame())
    employees = data.get("employees", pd.DataFrame())
    benefits = data.get("benefits", pd.DataFrame())
    feedback = data.get("feedback", pd.DataFrame())

    # Clean minimal types
    if not usage.empty and "LastUsedDate" in usage.columns:
        usage["LastUsedDate"] = pd.to_datetime(usage["LastUsedDate"], errors="coerce")
        usage["UsageFrequency"] = pd.to_numeric(usage["UsageFrequency"], errors="coerce").fillna(0)

    # Merge to a unified fact table
    fact = usage.copy()
    if not fact.empty and not employees.empty:
        fact = fact.merge(employees, on="EmployeeID", how="left")
    if not fact.empty and not benefits.empty:
        fact = fact.merge(benefits, on="BenefitID", how="left")
    if not fact.empty and not feedback.empty:
        # feedback may have multiple rows per (EmployeeID, BenefitID) — aggregate satisfaction
        fb = feedback.copy()
        fb["SatisfactionScore"] = pd.to_numeric(fb["SatisfactionScore"], errors="coerce")
        fb_agg = fb.groupby(["EmployeeID", "BenefitID"], as_index=False)["SatisfactionScore"].mean()
        fact = fact.merge(fb_agg, on=["EmployeeID", "BenefitID"], how="left")

    # Derived fields
    if not fact.empty:
        # Age bands
        bins = [0, 24, 34, 44, 54, 64, 200]
        labels = ["<25", "25-34", "35-44", "45-54", "55-64", "65+"]
        if "Age" in fact.columns:
            fact["AgeBand"] = pd.cut(fact["Age"], bins=bins, labels=labels, include_lowest=True)
        # Tenure bands (years)
        if "Tenure" in fact.columns:
            tbins = [-1, 1, 3, 5, 10, 50]
            tlabels = ["<1y", "1-3y", "3-5y", "5-10y", "10y+"]
            fact["TenureBand"] = pd.cut(fact["Tenure"], bins=tbins, labels=tlabels)
        # Utilization proxy: usage frequency > 0 counts as utilized
        fact["Utilized"] = (fact.get("UsageFrequency", 0) > 0).astype(int)
        # Cost proxy: duplicate BenefitCost onto each row for aggregation
        if "BenefitCost" in fact.columns:
            fact["BenefitCost"] = pd.to_numeric(fact["BenefitCost"], errors="coerce")

    return fact

# -----------------------------
# Simple "Generative" Insight (rule-based) over comments
# -----------------------------
COMMON_STOP = set("""
a an and are as at be by for from has have he her his i in is it its of on or that the their they to was were will with you your our we not very
""".split())

@st.cache_data(show_spinner=False)
def summarize_feedback(feedback_df: pd.DataFrame, top_n: int = 8) -> list[str]:
    """Very simple keyword-based summary ‘insights’. If Comments exist, find frequent
    meaningful tokens and emit bullets as pseudo-insights. This is a lightweight stand-in
    for LLM tooltips/annotations.
    """
    if feedback_df.empty or "Comments" not in feedback_df.columns:
        return []
    # Tokenize and count
    words = []
    for c in feedback_df["Comments"].dropna().astype(str).tolist():
        # crude tokenization
        for w in c.lower().replace("/", " ").replace("-", " ").split():
            w = "".join(ch for ch in w if ch.isalpha())
            if len(w) >= 4 and w not in COMMON_STOP:
                words.append(w)
    if not words:
        return []
    vc = pd.Series(words).value_counts().head(top_n)
    bullets = [f"Frequent theme: '{w}' (mentions≈{int(n)})" for w, n in vc.items()]
    return bullets

# -----------------------------
# KPI & ROI helpers
# -----------------------------
@st.cache_data(show_spinner=False)
def compute_kpis(fact: pd.DataFrame) -> dict:
    if fact.empty:
        return {
            "utilization_rate": 0.0,
            "avg_satisfaction": np.nan,
            "active_population": 0,
            "est_cost": ANNUAL_BENEFITS_COST,
            "roi_index": np.nan,
        }

    # Utilization rate: share of unique employees with any usage
    utilized_emp = fact.groupby("EmployeeID")["Utilized"].max().sum()
    total_emp = fact["EmployeeID"].nunique() or EMPLOYEES
    utilization_rate = utilized_emp / total_emp if total_emp else 0

    avg_sat = fact["SatisfactionScore"].mean(skipna=True)

    # Simple ROI index (illustrative): (avg usage per employee * avg satisfaction) / (avg cost per benefit)
    avg_usage_per_emp = fact.groupby("EmployeeID")["UsageFrequency"].sum().mean()
    avg_cost_per_benefit = fact["BenefitCost"].replace(0, np.nan).mean(skipna=True)
    roi_index = (avg_usage_per_emp * (avg_sat or 0)) / avg_cost_per_benefit if avg_cost_per_benefit and avg_sat else np.nan

    return {
        "utilization_rate": utilization_rate,
        "avg_satisfaction": avg_sat,
        "active_population": int(utilized_emp),
        "est_cost": ANNUAL_BENEFITS_COST,
        "roi_index": roi_index,
    }

# -----------------------------
# Sidebar Filters
# -----------------------------

def build_filters(fact: pd.DataFrame) -> pd.DataFrame:
    st.sidebar.header("Filters")
    df = fact.copy()
    if df.empty:
        return df

    # Department filter
    if "Department" in df.columns:
        depts = ["All"] + sorted([d for d in df["Department"].dropna().unique().tolist()])
        dept_sel = st.sidebar.selectbox("Department", depts, index=0)
        if dept_sel != "All":
            df = df[df["Department"] == dept_sel]

    # Age range
    if "Age" in df.columns and df["Age"].notna().any():
        min_age = int(np.nanmin(df["Age"]))
        max_age = int(np.nanmax(df["Age"]))
        age_min, age_max = st.sidebar.slider("Age Range", min_age, max_age, (min_age, max_age))
        df = df[(df["Age"] >= age_min) & (df["Age"] <= age_max)]

    # BenefitSubType multi-select
    if "BenefitSubType" in df.columns:
        subs = sorted(df["BenefitSubType"].dropna().unique().tolist())
        sel_subs = st.sidebar.multiselect("Benefit SubType", options=subs, default=subs[: min(5, len(subs))])
        if sel_subs:
            df = df[df["BenefitSubType"].isin(sel_subs)]

    # Date range on LastUsedDate
    if "LastUsedDate" in df.columns and df["LastUsedDate"].notna().any():
        min_d = pd.to_datetime(df["LastUsedDate"]).min()
        max_d = pd.to_datetime(df["LastUsedDate"]).max()
        d1, d2 = st.sidebar.date_input("Usage Date Range", value=(min_d, max_d))
        try:
            df = df[(df["LastUsedDate"] >= pd.to_datetime(d1)) & (df["LastUsedDate"] <= pd.to_datetime(d2))]
        except Exception:
            pass

    return df

# -----------------------------
# Visual Components
# -----------------------------

def kpi_cards(kpis: dict):
    c1, c2, c3, c4 = st.columns(4)
    c1.metric("Utilization Rate", f"{kpis['utilization_rate']:.1%}", help="Share of employees with any benefit usage in the period.")
    if np.isnan(kpis["avg_satisfaction"]) or kpis["avg_satisfaction"] is None:
        sat_txt = "N/A"
    else:
        sat_txt = f"{kpis['avg_satisfaction']:.2f} / 5"
    c2.metric("Avg Satisfaction", sat_txt, help="Mean SatisfactionScore across feedback.")
    c3.metric("Active Employees", f"{kpis['active_population']:,}", help="Employees with at least one utilization event.")
    c4.metric("ROI Index (proxy)", f"{kpis['roi_index']:.3f}" if kpis['roi_index'] == kpis['roi_index'] else "N/A", help="(Avg usage per employee × avg satisfaction) / avg benefit cost.")


def usage_trend_chart(df: pd.DataFrame):
    if df.empty or "LastUsedDate" not in df.columns:
        st.info("Usage trend requires usage_data with LastUsedDate.")
        return
    temp = df.copy()
    temp["Month"] = temp["LastUsedDate"].dt.to_period("M").dt.to_timestamp()
    trend = temp.groupby("Month", as_index=False)["UsageFrequency"].sum()
    fig = px.line(trend, x="Month", y="UsageFrequency", title="Usage Over Time")
    st.plotly_chart(fig, use_container_width=True)


def satisfaction_by_benefit(df: pd.DataFrame):
    if df.empty or "SatisfactionScore" not in df.columns or "BenefitType" not in df.columns:
        st.info("Satisfaction by Benefit requires feedback_data and benefits_data.")
        return
    agg = df.groupby(["BenefitType", "BenefitSubType"], as_index=False)["SatisfactionScore"].mean()
    chart = alt.Chart(agg).mark_bar().encode(
        x=alt.X("mean(SatisfactionScore):Q", title="Avg Satisfaction"),
        y=alt.Y("BenefitSubType:N", sort='-x', title="Benefit SubType"),
        color="BenefitType:N",
        tooltip=["BenefitType", "BenefitSubType", alt.Tooltip("SatisfactionScore:Q", title="Avg Sat", format=".2f")]
    ).properties(title="Average Satisfaction by Benefit")
    st.altair_chart(chart, use_container_width=True)


def dept_utilization_heatmap(df: pd.DataFrame):
    if df.empty or "Department" not in df.columns:
        st.info("Department utilization heatmap requires employee_data with Department.")
        return
    agg = df.groupby(["Department", "BenefitType"], as_index=False)["Utilized"].mean()
    pivot = agg.pivot(index="Department", columns="BenefitType", values="Utilized").fillna(0)
    heat_df = pivot.reset_index().melt(id_vars="Department", var_name="BenefitType", value_name="UtilizationRate")
    fig = px.density_heatmap(heat_df, x="BenefitType", y="Department", z="UtilizationRate", title="Utilization Rate by Department & Benefit Type", nbinsx=20, nbinsy=20)
    st.plotly_chart(fig, use_container_width=True)


def segment_distribution(df: pd.DataFrame):
    if df.empty or "AgeBand" not in df.columns or "TenureBand" not in df.columns:
        st.info("Segment distribution requires Age/Tenure bands.")
        return
    agg = df.groupby(["AgeBand", "TenureBand"], as_index=False)["EmployeeID"].nunique()
    agg.rename(columns={"EmployeeID": "Employees"}, inplace=True)
    chart = alt.Chart(agg).mark_circle(size=200).encode(
        x=alt.X("AgeBand:N", title="Age Band"),
        y=alt.Y("TenureBand:N", title="Tenure Band"),
        size=alt.Size("Employees:Q", title="# Employees"),
        tooltip=["AgeBand", "TenureBand", "Employees"]
    ).properties(title="Population Segments (Age × Tenure)")
    st.altair_chart(chart, use_container_width=True)

# -----------------------------
# Export helpers
# -----------------------------

def build_html_export(kpis: dict, insights: list[str]) -> str:
    kpi_html = f"""
    <h2>{COMPANY} — KPI Snapshot</h2>
    <ul>
      <li><b>Utilization Rate:</b> {kpis['utilization_rate']:.1%}</li>
      <li><b>Average Satisfaction:</b> {('N/A' if np.isnan(kpis['avg_satisfaction']) else f"{kpis['avg_satisfaction']:.2f} / 5")}</li>
      <li><b>Active Employees:</b> {kpis['active_population']:,}</li>
      <li><b>ROI Index (proxy):</b> {('N/A' if np.isnan(kpis['roi_index']) else f"{kpis['roi_index']:.3f}")}</li>
      <li><b>Annual Benefits Cost:</b> ${ANNUAL_BENEFITS_COST:,.0f} (YoY +{int(YOY_COST_INCREASE*100)}%)</li>
    </ul>
    """
    insight_html = ""
    if insights:
        lis = "\n".join(f"<li>{st.session_state.get('insight_prefix', 'Insight')}: {st._escape_html(b)}</li>" for b in insights)
        insight_html = f"<h3>Feedback Themes</h3><ul>{lis}</ul>"
    html = f"""
    <html><head><meta charset='utf-8'><title>{COMPANY} Dashboard Export</title></head>
    <body style='font-family:Arial, sans-serif; padding: 1rem 2rem;'>
      <h1>{COMPANY} — Benefits Analytics Export</h1>
      <p>Generated: {datetime.utcnow().strftime('%Y-%m-%d %H:%M UTC')}</p>
      {kpi_html}
      {insight_html}
      <p style='color:#666'>Note: ROI index and insights are proxies for decision support.</p>
    </body></html>
    """
    return html


def download_html_button(html_str: str, filename: str = "dashboard_export.html"):
    b = html_str.encode("utf-8")
    st.download_button("Download HTML Export", data=b, file_name=filename, mime="text/html")

# -----------------------------
# Main App
# -----------------------------

def main():
    st.title(f"{COMPANY} — Benefits Analytics Dashboard")
    st.caption("Phase 4: Interactive BI Dashboard with caching, filters, AI-ish insights, and export.")

    data = load_all_data(DATA_DIR)
    fact = integrate(data)

    if fact.empty:
        st.stop()

    # Filters
    fdf = build_filters(fact)

    # KPIs
    kpis = compute_kpis(fdf)
    kpi_cards(kpis)

    # Layout
    st.markdown("---")
    c1, c2 = st.columns([1, 1])
    with c1:
        usage_trend_chart(fdf)
        segment_distribution(fdf)
    with c2:
        satisfaction_by_benefit(fdf)
        dept_utilization_heatmap(fdf)

    st.markdown("---")
    st.subheader("Generative Insights (auto-summarized feedback themes)")
    insights = summarize_feedback(data.get("feedback", pd.DataFrame()))
    if insights:
        for b in insights:
            st.write("• ", b)
    else:
        st.info("No feedback comments found to summarize.")

    # Export
    st.markdown("---")
    st.subheader("Export")
    html_export = build_html_export(kpis, insights)
    download_html_button(html_export)

    with st.expander("About the metrics & ROI proxy"):
        st.markdown(
            """
            **Utilization Rate**: share of unique employees with any recorded benefit usage in the selected period.  
            **Avg Satisfaction**: mean of `SatisfactionScore`.  
            **ROI Index (proxy)**: (Avg usage per employee × Avg satisfaction) / Avg benefit cost. This is an illustrative index, not a financial statement.  
            **Export**: Downloads a lightweight HTML containing KPI snapshot and feedback themes.
            """
        )


# -----------------------------
# CLI convenience: allow `python app.py` to spawn Streamlit
# -----------------------------
if __name__ == "__main__":
    # If running via `streamlit run app.py`, execute main().
    # If running via `python app.py`, try to spawn streamlit subprocess for convenience.
    if any("streamlit" in arg for arg in sys.argv):
        main()
    else:
        try:
            # Launch streamlit and attach to current file
            cmd = [sys.executable, "-m", "streamlit", "run", __file__]
            print("Launching Streamlit server... If nothing happens, run: streamlit run app.py")
            subprocess.run(cmd, check=False)
        except Exception as e:
            print("Failed to launch Streamlit automatically. Please run: streamlit run app.py")
            print(e)
